# -*- coding: utf-8 -*-
"""0000000_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A0MrZqwpIKfWKGrS_Hcd4YDI7dCpKuoD

# Artificial Intelligence - Assignment 1

## 1. Description

In this assignment, you are going to solve the 8-puzzle using any algorithm. The `EightPuzzle` class is written and provided by TAs, you don't need to implement the puzzle yourself, just import and use.

## 2. How to use `EightPuzzle`

```python
from eight_puzzle import EightPuzzle # import

puzzle = EightPuzzle()

puzzle.init()     # initialize a solvable puzzle state
puzzle.init(seed) # initialize a solvable puzzle state using a seed
print(puzzle)     # show current puzzle state

# move
puzzle.move('up')
puzzle.move('down')
puzzle.move('left')
puzzle.move('right')

if puzzle.state == puzzle.FINAL_STATE:
  print('You have solved the puzzle')

# Useful: get the next state after you move in a direction,
# this won't change the internal state of EightPuzzle.
state_after_move_up = puzzle.get_state_after_move(current_state, 'up')

```
"""

# NOTE: PLEASE KEEP THIS CELL AND DO NOT MODIFY!

# download eight_puzzle.py (YOU SHOULD NOT MODIFY eight_puzzle.py)
!wget https://lab.djosix.com/eight_puzzle.py -qO eight_puzzle.py
!sha1sum eight_puzzle.py

from eight_puzzle import EightPuzzle, test

"""## 3. Implement a search algorithm to solve 8-puzzle"""

def solve(p):
    class node:
        def __init__(self,state,parent=None,step=None,fval=0,level=0):
            self.state  = state
            self.parent = parent
            self.step = step
            self.level = level
            self.fval = self.calculate_fval(p.FINAL_STATE)
        # explore func is used to expand the current state 
        def explore(self):
            children = []
            U = p.get_state_after_move(self.state,"up")
            D = p.get_state_after_move(self.state,"down")
            L = p.get_state_after_move(self.state,"left")
            R = p.get_state_after_move(self.state,"right")
            if U is not None:
                child_node0 = node(U,self,"up",0,self.level+1)
                children.append(child_node0)
            if D is not None:
                child_node1 = node(D,self,"down",0,self.level+1)
                children.append(child_node1)
            if L is not None:
                child_node2 = node(L,self,"left",0,self.level+1)
                children.append(child_node2)
            if R is not None:
                child_node3 = node(R,self,"right",0,self.level+1)
                children.append(child_node3)
            
            return children
        def calculate_huristic(self,final):
          temp = 0
          idx = 0
          for i in self.state:
            if (i-1)!=idx and i!=0:
              x=abs((i-1)%3-idx%3)
              y=abs((i-1)//3-idx//3)
              temp += (x+y)
            idx += 1
          return temp
        def calculate_fval(self,final):
          return self.calculate_huristic(final)+self.level
    
        
    
    
    def find(now,arr):
      for i in range(len(arr)):
        if now.state == arr[i].state:
          return i
      return -1

    root = node(p.state,None,None,0,0)
    open1 = []
    closed = []
    open1.append(root)
    while True:
        # idx =0
        # min = open1[0]
        # for i in range(len(open1)):
        #   if open1[i].fval<min.fval:
        #     min = open1[i]
        #     idx = i
        current_node  = open1[0]
        closed.append(current_node)
        # del open1[idx]
        if(current_node.calculate_huristic(p.FINAL_STATE)==0):
            break
        for child in current_node.explore():
          if find(child,closed)!=-1:
            continue
          temp=find(child,open1)
          if temp!=-1:
            if child.fval < open1[temp].fval:
              open1[temp] = child
              continue
          open1.append(child)
        del open1[0]
        open1 =  sorted(open1, key=lambda p: p.fval)
        # closed.append(current_node)
        # del open1[0]
        # open.sort(key = lambda x:x.fval,reverse =False)
        
    
    trace_back = open1[0]
    ans_r = []
    while True:
        ans_r.append(trace_back.step)
        # ans_r.insert(0,trace_back.step)
        #print(trace_back.state)
        trace_back = trace_back.parent
        if trace_back.state == p.state:
          #print(trace_back.state)
          break
    ans_r.reverse()
    return ans_r

"""## 4. Test your algorithm"""

# NOTE: PLEASE KEEP THIS CELL AND DO NOT MODIFY!

results = test(solve, seed=123, n=10)

"""## 5. Submitting your assignment


1. You have to save 2 files:
  
  - Click "File" > "Download .ipynb" to download `XXXXXXX_1.ipynb`
  - Click "File" > "Download .py" to download `XXXXXXX_1.py`
  
  where `XXXXXXX` is your student ID.  

2. Compress these 2 files into a `.zip` file named `XXXXXXX_1.zip`.

3. Upload the zip file to E3.

> **NOTE: You should click "Runtime" > "Restart and run all" before submitting to E3 to check if your program is able to run without any exception.**
"""